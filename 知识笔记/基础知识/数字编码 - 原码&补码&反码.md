---
tags:
  - 知识笔记/基础知识
---
#### 原码

>原码就是数字的原始二进制表示，最高位作为符号位

#### 反码

>正数的反码就是它本身，负数的反码是对原码除符号位之外的其余位取反

#### 补码

>正数的补码是它本身，负数的补码是在反码的基础上+1

#### 解释

>[!Info] 为什么会出现反码？  
>比如在原码的基础上计算1 + (-2),详细步骤如下： 
>```
1 + (-2)
-> 0000 0001 + 1000 0010
-> 1000 0011
-> -3
>```
>结果显然有问题，所以原码并不能直接用于运算，由此引入了反码：
>```
1 + (-2)
-> 0000 0001 + 1000 0010  原码
-> 0000 0001 + 1111 1101  反码
-> 1111 1110
-> 1000 0001
-> -1
>```
>这样计算就正常了，但是反码又有一个很奇怪的问题就是会出现正负零的问题，就是说`0000 0000`和`1000 0000`分别代表+0和-0，如果这样计算就会出现歧义，cpu需要为正负零进行额外处理，位了处理这个问题，科学家又提出了补码的概念：
>```
1 + （-2）
-> 0000 0001 + 1000 0010  原码
-> 0000 0001 + 1111 1101  反码
-> 0000 0001 + 1111 1110  补码
-> 1111 1111
-> 1111 1110 补码
-> 1000 0001 反码
-> -1 结果
>```
>这样既保证计算结果的正确，又消除了正负零的歧义，因为：
>```
   1000 0000 -0的原码
-> 1111 1111 反码
->10000 0000 补码
>```
#### 浮点数编码

>[!Info]
>首先浮点数编码和整数编码方式不一样，这就是为什么int和float同是4个字节，反而浮点数能表示的数比整数还多，按理说浮点数需要几位表示小数，取值范围应该变小才对，浮点数的编码方式如下：
>假设一个浮点数占4个字节，那么它的32位二进制数我们表示为：
>`b31b30...b2b1b0`
>根据IEEE754标准，构成如下：
>1. 符号位S：占1位，对应b31
>2. 指数位E：占8位，对应b30-b23
>3. 分数位N：占23位，对应b22-b0
>4. 对应二进制的计算方法为：
>![示例图](https://cdn.nlark.com/yuque/__latex/1caf2b1cee30d8e28ede6a627890debd.svg)
>5. 对应十进制的计算公式：
>![示例图](https://cdn.nlark.com/yuque/__latex/2f7b2da150b607c719a1ab76343a6c1c.svg)
>6. 各项取值范围：
>![示例图](https://cdn.nlark.com/yuque/__latex/21093c39b7b17bb20283ae4fe8059239.svg)
>7. 所以浮点数虽然扩展的范围但是也一定程度上牺牲了精度
